import {
  _,
  l,
  x
} from "./chunk-UAOTPK2S.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/@sabaki/shudan/src/Goban.js
var import_classnames2 = __toESM(require_classnames());

// node_modules/@sabaki/shudan/src/helper.js
var alpha = "ABCDEFGHJKLMNOPQRSTUVWXYZ";
var vertexEvents = [
  "Click",
  "MouseDown",
  "MouseUp",
  "MouseMove",
  "MouseEnter",
  "MouseLeave",
  "PointerDown",
  "PointerUp",
  "PointerMove",
  "PointerEnter",
  "PointerLeave"
];
var avg = (xs) => xs.length === 0 ? 0 : xs.reduce((sum, x2) => sum + x2, 0) / xs.length;
var range = (n) => Array(n).fill(0).map((_2, i2) => i2);
var random = (n) => Math.floor(Math.random() * (n + 1));
var neighborhood = ([x2, y]) => [
  [x2, y],
  [x2 - 1, y],
  [x2 + 1, y],
  [x2, y - 1],
  [x2, y + 1]
];
var vertexEquals = ([x1, y1], [x2, y2]) => x1 === x2 && y1 === y2;
var signEquals = (...xs) => xs.length === 0 ? true : xs.every((x2) => Math.sign(x2) === Math.sign(xs[0]));
function getHoshis(width, height) {
  if (Math.min(width, height) <= 6) return [];
  let [nearX, nearY] = [width, height].map((x2) => x2 >= 13 ? 3 : 2);
  let [farX, farY] = [width - nearX - 1, height - nearY - 1];
  let [middleX, middleY] = [width, height].map((x2) => (x2 - 1) / 2);
  let result = [
    [nearX, farY],
    [farX, nearY],
    [farX, farY],
    [nearX, nearY]
  ];
  if (width % 2 !== 0 && height % 2 !== 0 && width !== 7 && height !== 7)
    result.push([middleX, middleY]);
  if (width % 2 !== 0 && width !== 7)
    result.push([middleX, nearY], [middleX, farY]);
  if (height % 2 !== 0 && height !== 7)
    result.push([nearX, middleY], [farX, middleY]);
  return result;
}
function readjustShifts(shiftMap, vertex = null) {
  if (vertex == null) {
    for (let y = 0; y < shiftMap.length; y++) {
      for (let x2 = 0; x2 < shiftMap[0].length; x2++) {
        readjustShifts(shiftMap, [x2, y]);
      }
    }
  } else {
    let [x2, y] = vertex;
    let direction = shiftMap[y][x2];
    let data = [
      // Left
      [
        [1, 5, 8],
        [x2 - 1, y],
        [3, 7, 6]
      ],
      // Top
      [
        [2, 5, 6],
        [x2, y - 1],
        [4, 7, 8]
      ],
      // Right
      [
        [3, 7, 6],
        [x2 + 1, y],
        [1, 5, 8]
      ],
      // Bottom
      [
        [4, 7, 8],
        [x2, y + 1],
        [2, 5, 6]
      ]
    ];
    for (let [directions, [qx, qy], removeShifts] of data) {
      if (!directions.includes(direction)) continue;
      if (shiftMap[qy] && removeShifts.includes(shiftMap[qy][qx])) {
        shiftMap[qy][qx] = 0;
      }
    }
  }
  return shiftMap;
}
function diffSignMap(before, after) {
  if (before === after || before.length === 0 || before.length !== after.length || before[0].length !== after[0].length) {
    return [];
  }
  let result = [];
  for (let y = 0; y < before.length; y++) {
    for (let x2 = 0; x2 < before[0].length; x2++) {
      if (before[y][x2] === 0 && after[y] != null && after[y][x2]) {
        result.push([x2, y]);
      }
    }
  }
  return result;
}

// node_modules/@sabaki/shudan/src/Coord.js
var CoordX = class extends x {
  render() {
    let {
      style,
      xs,
      coordX = (i2) => alpha[i2] || alpha[alpha.length - 1]
    } = this.props;
    return _(
      "div",
      {
        className: "shudan-coordx",
        style: {
          display: "flex",
          textAlign: "center",
          ...style
        }
      },
      xs.map(
        (i2) => _(
          "div",
          { key: i2, style: { width: "1em" } },
          _("span", { style: { display: "block" } }, coordX(i2))
        )
      )
    );
  }
};
var CoordY = class extends x {
  render() {
    let { style, height, ys, coordY = (i2) => height - i2 } = this.props;
    return _(
      "div",
      {
        className: "shudan-coordy",
        style: {
          textAlign: "center",
          ...style
        }
      },
      ys.map(
        (i2) => _(
          "div",
          { key: i2, style: { height: "1em" } },
          _("span", { style: { display: "block" } }, coordY(i2))
        )
      )
    );
  }
};

// node_modules/@sabaki/shudan/src/Grid.js
var Grid = class extends x {
  shouldComponentUpdate(nextProps) {
    return nextProps.vertexSize !== this.props.vertexSize || nextProps.width !== this.props.width || nextProps.height !== this.props.height || nextProps.xs.length !== this.props.xs.length || nextProps.ys.length !== this.props.ys.length || nextProps.xs[0] !== this.props.xs[0] || nextProps.ys[0] !== this.props.ys[0];
  }
  render() {
    let { vertexSize, width, height, xs, ys, hoshis } = this.props;
    let halfVertexSize = vertexSize / 2;
    return xs.length > 0 && ys.length > 0 && _(
      "svg",
      {
        className: "shudan-grid",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          zIndex: 0
        }
      },
      // Draw grid lines
      ys.map((_2, i2) => {
        let x2 = xs[0] === 0 ? halfVertexSize : 0;
        return _("rect", {
          key: `h${i2}`,
          className: "shudan-gridline shudan-horizontal",
          x: x2,
          y: (2 * i2 + 1) * halfVertexSize,
          width: xs[xs.length - 1] === width - 1 ? (2 * xs.length - 1) * halfVertexSize - x2 : xs.length * vertexSize - x2,
          height: 1
        });
      }),
      xs.map((_2, i2) => {
        let y = ys[0] === 0 ? halfVertexSize : 0;
        return _("rect", {
          key: `v${i2}`,
          className: "shudan-gridline shudan-vertical",
          x: (2 * i2 + 1) * halfVertexSize,
          y,
          width: 1,
          height: ys[ys.length - 1] === height - 1 ? (2 * ys.length - 1) * halfVertexSize - y : ys.length * vertexSize - y
        });
      }),
      // Draw hoshi points
      hoshis.map(([x2, y]) => {
        let i2 = xs.indexOf(x2);
        let j2 = ys.indexOf(y);
        if (i2 < 0 || j2 < 0) return;
        return _("circle", {
          key: [x2, y].join("-"),
          className: "shudan-hoshi",
          cx: (2 * i2 + 1) * halfVertexSize + 0.5,
          cy: (2 * j2 + 1) * halfVertexSize + 0.5,
          r: ".1em"
        });
      })
    );
  }
};

// node_modules/preact/hooks/dist/hooks.module.js
var t;
var r;
var u;
var i;
var o = 0;
var f = [];
var c = l;
var e = c.__b;
var a = c.__r;
var v = c.diffed;
var l2 = c.__c;
var m = c.unmount;
var s = c.__;
function p(n, t2) {
  c.__h && c.__h(r, n, o || t2), o = 0;
  var u2 = r.__H || (r.__H = { __: [], __h: [] });
  return n >= u2.__.length && u2.__.push({}), u2.__[n];
}
function T(n, r2) {
  var u2 = p(t++, 7);
  return C(u2.__H, r2) && (u2.__ = n(), u2.__H = r2, u2.__h = n), u2.__;
}
function q(n, t2) {
  return o = 8, T(function() {
    return n;
  }, t2);
}
function j() {
  for (var n; n = f.shift(); ) if (n.__P && n.__H) try {
    n.__H.__h.forEach(z), n.__H.__h.forEach(B), n.__H.__h = [];
  } catch (t2) {
    n.__H.__h = [], c.__e(t2, n.__v);
  }
}
c.__b = function(n) {
  r = null, e && e(n);
}, c.__ = function(n, t2) {
  n && t2.__k && t2.__k.__m && (n.__m = t2.__k.__m), s && s(n, t2);
}, c.__r = function(n) {
  a && a(n), t = 0;
  var i2 = (r = n.__c).__H;
  i2 && (u === r ? (i2.__h = [], r.__h = [], i2.__.forEach(function(n2) {
    n2.__N && (n2.__ = n2.__N), n2.u = n2.__N = void 0;
  })) : (i2.__h.forEach(z), i2.__h.forEach(B), i2.__h = [], t = 0)), u = r;
}, c.diffed = function(n) {
  v && v(n);
  var t2 = n.__c;
  t2 && t2.__H && (t2.__H.__h.length && (1 !== f.push(t2) && i === c.requestAnimationFrame || ((i = c.requestAnimationFrame) || w)(j)), t2.__H.__.forEach(function(n2) {
    n2.u && (n2.__H = n2.u), n2.u = void 0;
  })), u = r = null;
}, c.__c = function(n, t2) {
  t2.some(function(n2) {
    try {
      n2.__h.forEach(z), n2.__h = n2.__h.filter(function(n3) {
        return !n3.__ || B(n3);
      });
    } catch (r2) {
      t2.some(function(n3) {
        n3.__h && (n3.__h = []);
      }), t2 = [], c.__e(r2, n2.__v);
    }
  }), l2 && l2(n, t2);
}, c.unmount = function(n) {
  m && m(n);
  var t2, r2 = n.__c;
  r2 && r2.__H && (r2.__H.__.forEach(function(n2) {
    try {
      z(n2);
    } catch (n3) {
      t2 = n3;
    }
  }), r2.__H = void 0, t2 && c.__e(t2, r2.__v));
};
var k = "function" == typeof requestAnimationFrame;
function w(n) {
  var t2, r2 = function() {
    clearTimeout(u2), k && cancelAnimationFrame(t2), setTimeout(n);
  }, u2 = setTimeout(r2, 35);
  k && (t2 = requestAnimationFrame(r2));
}
function z(n) {
  var t2 = r, u2 = n.__c;
  "function" == typeof u2 && (n.__c = void 0, u2()), r = t2;
}
function B(n) {
  var t2 = r;
  n.__c = n.__(), r = t2;
}
function C(n, t2) {
  return !n || n.length !== t2.length || t2.some(function(t3, r2) {
    return t3 !== n[r2];
  });
}

// node_modules/@sabaki/shudan/src/Vertex.js
var import_classnames = __toESM(require_classnames());

// node_modules/@sabaki/shudan/src/Marker.js
function Marker({ sign, type, label, zIndex }) {
  let containerProps = {
    className: "shudan-marker",
    style: {
      position: "absolute",
      zIndex
    }
  };
  return type === "label" ? _("div", containerProps, label) : _(
    "svg",
    {
      ...containerProps,
      viewBox: "0 0 1 1"
    },
    type === "circle" || type === "loader" || type === "point" ? _("circle", {
      cx: 0.5,
      cy: 0.5,
      r: type === "point" ? 0.18 : 0.25,
      "vector-effect": "non-scaling-stroke"
    }) : type === "square" ? _("rect", {
      x: 0.25,
      y: 0.25,
      width: 0.5,
      height: 0.5,
      "vector-effect": "non-scaling-stroke"
    }) : type === "cross" ? [
      sign === 0 && _("rect", {
        x: 0.25,
        y: 0.25,
        width: 0.5,
        height: 0.5,
        stroke: "none"
      }),
      _("path", {
        d: "M 0 0 L .5 .5 M .5 0 L 0 .5",
        transform: "translate(.25 .25)",
        "vector-effect": "non-scaling-stroke"
      })
    ] : type === "triangle" ? _("path", {
      d: "M 0 .5 L .6 .5 L .3 0 z",
      transform: "translate(.2 .2)",
      "vector-effect": "non-scaling-stroke"
    }) : null
  );
}

// node_modules/@sabaki/shudan/src/Vertex.js
var absoluteStyle = (zIndex) => ({
  position: "absolute",
  zIndex
});
function Vertex(props) {
  let {
    position,
    shift,
    random: random2,
    sign,
    heat,
    paint,
    paintLeft,
    paintRight,
    paintTop,
    paintBottom,
    paintTopLeft,
    paintTopRight,
    paintBottomLeft,
    paintBottomRight,
    dimmed,
    marker,
    ghostStone,
    animate,
    selected,
    selectedLeft,
    selectedRight,
    selectedTop,
    selectedBottom
  } = props;
  let eventHandlers = {};
  for (let eventName of vertexEvents) {
    eventHandlers[eventName] = q(
      (evt) => {
        var _a;
        (_a = props[`on${eventName}`]) == null ? void 0 : _a.call(props, evt, position);
      },
      [...position, props[`on${eventName}`]]
    );
  }
  let markerMarkup = (zIndex) => !!marker && _(Marker, {
    key: "marker",
    sign,
    type: marker.type,
    label: marker.label,
    zIndex
  });
  return _(
    "div",
    Object.assign(
      {
        "data-x": position[0],
        "data-y": position[1],
        title: marker == null ? void 0 : marker.label,
        style: {
          position: "relative"
        },
        className: (0, import_classnames.default)(
          "shudan-vertex",
          `shudan-random_${random2}`,
          `shudan-sign_${sign}`,
          {
            [`shudan-shift_${shift}`]: !!shift,
            [`shudan-heat_${!!heat && heat.strength}`]: !!heat,
            "shudan-dimmed": dimmed,
            [`shudan-paint_${paint > 0 ? 1 : -1}`]: !!paint,
            "shudan-paintedleft": !!paint && Math.sign(paintLeft) === Math.sign(paint),
            "shudan-paintedright": !!paint && Math.sign(paintRight) === Math.sign(paint),
            "shudan-paintedtop": !!paint && Math.sign(paintTop) === Math.sign(paint),
            "shudan-paintedbottom": !!paint && Math.sign(paintBottom) === Math.sign(paint),
            "shudan-selected": selected,
            "shudan-selectedleft": selectedLeft,
            "shudan-selectedright": selectedRight,
            "shudan-selectedtop": selectedTop,
            "shudan-selectedbottom": selectedBottom,
            "shudan-animate": animate
          },
          marker && marker.type && `shudan-marker_${marker.type}`,
          marker && marker.type === "label" && marker.label && (marker.label.includes("\n") || marker.label.length >= 3) && `shudan-smalllabel`,
          ghostStone && `shudan-ghost_${ghostStone.sign}`,
          ghostStone && ghostStone.type && `shudan-ghost_${ghostStone.type}`,
          ghostStone && ghostStone.faint && `shudan-ghost_faint`
        )
      },
      ...vertexEvents.map((eventName) => ({
        [`on${eventName}`]: eventHandlers[eventName]
      }))
    ),
    !sign && markerMarkup(0),
    !sign && !!ghostStone && _("div", {
      key: "ghost",
      className: "shudan-ghost",
      style: absoluteStyle(1)
    }),
    _(
      "div",
      { key: "stone", className: "shudan-stone", style: absoluteStyle(2) },
      !!sign && _("div", {
        key: "shadow",
        className: "shudan-shadow",
        style: absoluteStyle()
      }),
      !!sign && _(
        "div",
        {
          key: "inner",
          className: (0, import_classnames.default)(
            "shudan-inner",
            "shudan-stone-image",
            `shudan-random_${random2}`,
            `shudan-sign_${sign}`
          ),
          style: absoluteStyle()
        },
        sign
      ),
      !!sign && markerMarkup()
    ),
    (!!paint || !!paintLeft || !!paintRight || !!paintTop || !!paintBottom) && _(
      "div",
      {
        key: "paint",
        className: "shudan-paint",
        style: absoluteStyle(3)
      },
      _("div", {
        className: "shudan-inner",
        style: {
          ...absoluteStyle(),
          opacity: avg(
            (!!paint ? [paint] : [paintLeft, paintRight, paintTop, paintBottom].map(
              (x2) => x2 !== 0 && !isNaN(x2)
            )).map((x2) => Math.abs(x2 ?? 0) * 0.5)
          ),
          boxShadow: [
            signEquals(paintLeft, paintTop, paintTopLeft) ? [Math.sign(paintTop), "-.5em -.5em"] : null,
            signEquals(paintRight, paintTop, paintTopRight) ? [Math.sign(paintTop), ".5em -.5em"] : null,
            signEquals(paintLeft, paintBottom, paintBottomLeft) ? [Math.sign(paintBottom), "-.5em .5em"] : null,
            signEquals(paintRight, paintBottom, paintBottomRight) ? [Math.sign(paintBottom), ".5em .5em"] : null
          ].filter((x2) => !!x2 && x2[0] !== 0).map(
            ([sign2, translation]) => `${translation} 0 0 var(${sign2 > 0 ? "--shudan-black-background-color" : "--shudan-white-background-color"})`
          ).join(",")
        }
      })
    ),
    !!selected && _("div", {
      key: "selection",
      className: "shudan-selection",
      style: absoluteStyle(4)
    }),
    _("div", {
      key: "heat",
      className: "shudan-heat",
      style: absoluteStyle(5)
    }),
    !!heat && _(
      "div",
      {
        key: "heatlabel",
        className: "shudan-heatlabel",
        style: absoluteStyle(6)
      },
      heat.text && heat.text.toString()
    )
  );
}

// node_modules/@sabaki/shudan/src/Line.js
var Line = class extends x {
  shouldComponentUpdate(nextProps) {
    let { v1, v2, type, vertexSize } = this.props;
    return type !== nextProps.type || vertexSize !== nextProps.vertexSize || !vertexEquals(v1, nextProps.v1) || !vertexEquals(v2, nextProps.v2);
  }
  render() {
    let { v1, v2, type = "line", vertexSize } = this.props;
    if (vertexEquals(v1, v2)) return;
    let [pos1, pos2] = [v1, v2].map((v3) => v3.map((x2) => x2 * vertexSize));
    let [dx, dy] = pos1.map((x2, i2) => pos2[i2] - x2);
    let [left, top] = pos1.map((x2, i2) => (x2 + pos2[i2] + vertexSize) / 2);
    let angle = Math.atan2(dy, dx) * 180 / Math.PI;
    let length = Math.sqrt(dx * dx + dy * dy);
    let right = left + length;
    return _("path", {
      className: `shudan-${type}`,
      d: `M ${left} ${top} h ${length} ${type === "arrow" ? (() => {
        let [x1, y1] = [right - vertexSize / 2, top - vertexSize / 4];
        let [x2, y2] = [right - vertexSize / 2, top + vertexSize / 4];
        return `L ${x1} ${y1} M ${right} ${top} L ${x2} ${y2}`;
      })() : ""}`,
      transform: `rotate(${angle} ${left} ${top}) translate(${-length / 2} 0)`
    });
  }
};

// node_modules/@sabaki/shudan/src/Goban.js
var Goban = class extends x {
  constructor(props) {
    super(props);
    this.state = {};
  }
  componentDidUpdate() {
    if (this.props.animateStonePlacement && !this.state.clearAnimatedVerticesHandler && this.state.animatedVertices.length > 0) {
      for (let [x2, y] of this.state.animatedVertices) {
        this.state.shiftMap[y][x2] = random(7) + 1;
        readjustShifts(this.state.shiftMap, [x2, y]);
      }
      this.setState({ shiftMap: this.state.shiftMap });
      this.setState({
        clearAnimatedVerticesHandler: setTimeout(() => {
          this.setState({
            animatedVertices: [],
            clearAnimatedVerticesHandler: null
          });
        }, this.props.animationDuration ?? 200)
      });
    }
  }
  render() {
    let { width, height, rangeX, rangeY, xs, ys, hoshis, shiftMap, randomMap } = this.state;
    let {
      innerProps = {},
      vertexSize = 24,
      coordX,
      coordY,
      busy,
      signMap,
      paintMap,
      heatMap,
      markerMap,
      ghostStoneMap,
      fuzzyStonePlacement = false,
      showCoordinates = false,
      lines = [],
      selectedVertices = [],
      dimmedVertices = []
    } = this.props;
    let animatedVertices = [].concat(
      ...this.state.animatedVertices.map(neighborhood)
    );
    return _(
      "div",
      {
        ...innerProps,
        id: this.props.id,
        className: (0, import_classnames2.default)("shudan-goban", "shudan-goban-image", {
          "shudan-busy": busy,
          "shudan-coordinates": showCoordinates
        }) + " " + (this.props.class ?? this.props.className ?? ""),
        style: {
          display: "inline-grid",
          gridTemplateRows: showCoordinates ? "1em 1fr 1em" : "1fr",
          gridTemplateColumns: showCoordinates ? "1em 1fr 1em" : "1fr",
          fontSize: vertexSize,
          lineHeight: "1em",
          ...this.props.style ?? {}
        }
      },
      showCoordinates && _(CoordX, { xs, style: { gridRow: "1", gridColumn: "2" }, coordX }),
      showCoordinates && _(CoordY, {
        height,
        ys,
        style: { gridRow: "2", gridColumn: "1" },
        coordY
      }),
      _(
        "div",
        {
          className: "shudan-content",
          style: {
            position: "relative",
            width: `${xs.length}em`,
            height: `${ys.length}em`,
            gridRow: showCoordinates ? "2" : "1",
            gridColumn: showCoordinates ? "2" : "1"
          }
        },
        _(Grid, {
          vertexSize,
          width,
          height,
          xs,
          ys,
          hoshis
        }),
        _(
          "div",
          {
            className: "shudan-vertices",
            style: {
              display: "grid",
              gridTemplateColumns: `repeat(${xs.length}, 1em)`,
              gridTemplateRows: `repeat(${ys.length}, 1em)`,
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              zIndex: 1
            }
          },
          ys.map(
            (y) => xs.map((x2) => {
              var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
              let equalsVertex = (v2) => vertexEquals(v2, [x2, y]);
              let selected = selectedVertices.some(equalsVertex);
              return _(
                Vertex,
                Object.assign(
                  {
                    key: [x2, y].join("-"),
                    position: [x2, y],
                    shift: fuzzyStonePlacement ? (_a = shiftMap == null ? void 0 : shiftMap[y]) == null ? void 0 : _a[x2] : 0,
                    random: (_b = randomMap == null ? void 0 : randomMap[y]) == null ? void 0 : _b[x2],
                    sign: (_c = signMap == null ? void 0 : signMap[y]) == null ? void 0 : _c[x2],
                    heat: (_d = heatMap == null ? void 0 : heatMap[y]) == null ? void 0 : _d[x2],
                    marker: (_e = markerMap == null ? void 0 : markerMap[y]) == null ? void 0 : _e[x2],
                    ghostStone: (_f = ghostStoneMap == null ? void 0 : ghostStoneMap[y]) == null ? void 0 : _f[x2],
                    dimmed: dimmedVertices.some(equalsVertex),
                    animate: animatedVertices.some(equalsVertex),
                    paint: (_g = paintMap == null ? void 0 : paintMap[y]) == null ? void 0 : _g[x2],
                    paintLeft: (_h = paintMap == null ? void 0 : paintMap[y]) == null ? void 0 : _h[x2 - 1],
                    paintRight: (_i = paintMap == null ? void 0 : paintMap[y]) == null ? void 0 : _i[x2 + 1],
                    paintTop: (_j = paintMap == null ? void 0 : paintMap[y - 1]) == null ? void 0 : _j[x2],
                    paintBottom: (_k = paintMap == null ? void 0 : paintMap[y + 1]) == null ? void 0 : _k[x2],
                    paintTopLeft: (_l = paintMap == null ? void 0 : paintMap[y - 1]) == null ? void 0 : _l[x2 - 1],
                    paintTopRight: (_m = paintMap == null ? void 0 : paintMap[y - 1]) == null ? void 0 : _m[x2 + 1],
                    paintBottomLeft: (_n = paintMap == null ? void 0 : paintMap[y + 1]) == null ? void 0 : _n[x2 - 1],
                    paintBottomRight: (_o = paintMap == null ? void 0 : paintMap[y + 1]) == null ? void 0 : _o[x2 + 1],
                    selected,
                    selectedLeft: selected && selectedVertices.some((v2) => vertexEquals(v2, [x2 - 1, y])),
                    selectedRight: selected && selectedVertices.some((v2) => vertexEquals(v2, [x2 + 1, y])),
                    selectedTop: selected && selectedVertices.some((v2) => vertexEquals(v2, [x2, y - 1])),
                    selectedBottom: selected && selectedVertices.some((v2) => vertexEquals(v2, [x2, y + 1]))
                  },
                  ...vertexEvents.map((e2) => ({
                    [`on${e2}`]: this.props[`onVertex${e2}`]
                  }))
                )
              );
            })
          )
        ),
        _(
          "svg",
          {
            className: "shudan-lines",
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              width: "100%",
              height: "100%",
              pointerEvents: "none",
              zIndex: 2
            }
          },
          _(
            "g",
            {
              transform: `translate(-${rangeX[0] * vertexSize} -${rangeY[0] * vertexSize})`
            },
            lines.map(
              ({ v1, v2, type }, i2) => _(Line, { key: i2, v1, v2, type, vertexSize })
            )
          )
        )
      ),
      showCoordinates && _(CoordY, {
        height,
        ys,
        style: { gridRow: "2", gridColumn: "3" },
        coordY
      }),
      showCoordinates && _(CoordX, { xs, style: { gridRow: "3", gridColumn: "2" }, coordX })
    );
  }
};
Goban.getDerivedStateFromProps = function(props, state) {
  let { signMap = [], rangeX = [0, Infinity], rangeY = [0, Infinity] } = props;
  let width = signMap.length === 0 ? 0 : signMap[0].length;
  let height = signMap.length;
  if (state.width === width && state.height === height) {
    let animatedVertices = state.animatedVertices;
    if (props.animateStonePlacement && props.fuzzyStonePlacement && state.clearAnimatedVerticesHandler == null) {
      animatedVertices = diffSignMap(state.signMap, signMap);
    }
    let result = {
      signMap,
      animatedVertices
    };
    if (!vertexEquals(state.rangeX, rangeX) || !vertexEquals(state.rangeY, rangeY)) {
      Object.assign(result, {
        rangeX,
        rangeY,
        xs: range(width).slice(rangeX[0], rangeX[1] + 1),
        ys: range(height).slice(rangeY[0], rangeY[1] + 1)
      });
    }
    return result;
  }
  return {
    signMap,
    width,
    height,
    rangeX,
    rangeY,
    animatedVertices: [],
    clearAnimatedVerticesHandler: null,
    xs: range(width).slice(rangeX[0], rangeX[1] + 1),
    ys: range(height).slice(rangeY[0], rangeY[1] + 1),
    hoshis: getHoshis(width, height),
    shiftMap: readjustShifts(signMap.map((row) => row.map((_2) => random(8)))),
    randomMap: signMap.map((row) => row.map((_2) => random(4)))
  };
};

// node_modules/@sabaki/shudan/src/BoundedGoban.js
var BoundedGoban = class extends x {
  constructor(props) {
    super(props);
    this.state = {
      vertexSize: 1,
      visibility: "hidden"
    };
  }
  componentDidMount() {
    this.componentDidUpdate();
  }
  componentDidUpdate(prevProps) {
    let {
      showCoordinates,
      maxWidth,
      maxHeight,
      maxVertexSize,
      rangeX,
      rangeY,
      signMap,
      onResized = () => {
      }
    } = this.props;
    if (this.state.visibility !== "visible" || showCoordinates !== prevProps.showCoordinates || maxWidth !== prevProps.maxWidth || maxHeight !== prevProps.maxHeight || maxVertexSize !== prevProps.maxVertexSize || JSON.stringify(rangeX) !== JSON.stringify(prevProps.rangeX) || JSON.stringify(rangeY) !== JSON.stringify(prevProps.rangeY) || signMap.length !== prevProps.signMap.length || (signMap[0] || []).length !== (prevProps.signMap[0] || []).length) {
      let { offsetWidth, offsetHeight } = this.element;
      let scale = Math.min(maxWidth / offsetWidth, maxHeight / offsetHeight);
      let vertexSize = Math.max(Math.floor(this.state.vertexSize * scale), 1);
      if (this.state.vertexSize !== vertexSize) {
        this.setState({ vertexSize }, onResized);
      }
      if (this.state.visibility !== "visible") {
        this.setState({ visibility: "visible" });
      }
    }
  }
  render() {
    let { innerProps = {}, style = {}, maxVertexSize = Infinity } = this.props;
    let { ref: innerRef = () => {
    } } = innerProps;
    return _(Goban, {
      ...this.props,
      innerProps: {
        ...innerProps,
        ref: (el) => (innerRef(el), this.element = el)
      },
      style: {
        visibility: this.state.visibility,
        ...style
      },
      vertexSize: Math.min(this.state.vertexSize, maxVertexSize)
    });
  }
};
export {
  BoundedGoban,
  Goban
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=@sabaki_shudan.js.map
